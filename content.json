[{"title":"KMP 算法的 Java 实现","date":"2018-03-24T02:42:37.442Z","path":"2018/03/24/notes_03/","text":"KMP 算法简介定义 Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。KMP算法的时间复杂度比朴素算法的要少，并且是线性时间复杂度，即预处理时间复杂度是O(m)，匹配时间复杂度是O(n)。 下面先直接给出KMP的算法流程：1）假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符； 2）如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。 3）换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的 next 值，即移动的实际位数为：j - next[j]，且此值大于等于1。 不难看出，KMP 算法的重点在于如何求 next 数组。 PS: next数组含义：代表在模式串P中，当前下标对应的字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next [j] = k，代表在模式串P中，下标为j的字符之前的字符串中有最大长度为k 的相同前缀后缀。 下面给出next数组求解方法： next[0] = -1; 如果已知next[j] = k,如何求出next[j+1]呢?具体算法如下: 1）如果p[j] = p[k], 则next[j+1] = next[k] + 1; 2）如果p[j] != p[k], 则令k=next[k],如果此时p[j]==p[k],next[j+1]=k+1,如果不相等,则继续递归前缀索引,令 k=next[k],继续判断,直至k=-1(即k=next[0])或者p[j]=p[k]为止。 下面给出求next数组的方法： 1234567891011121314151617public static int[] getNext(char[] p)&#123; int pLen = p.length; int[] next = new int[pLen]; int k = -1; int j = 0; next[0] = -1; while(j &lt; pLen - 1)&#123; if(k == -1 || p[j] == p[k])&#123; k++; j++; next[j] = k; &#125;else&#123; k = next[k]; &#125; &#125; return next;&#125; 这样基本求next数组的方法就有了，但是，该算法依然有优化的空间。优化的点在于如果p[k] == k[next[k]]，则后面必然失配。因此，当出现 p[k] == k[next[k]]的情况时，需要再次递归，即next[k] = next[next[k]]; 下面给出优化的求 next 数组的方法： 123456789101112131415161718192021public static int[] getNext(char[] p)&#123; int pLen = p.length; int[] next = new int[pLen]; int k = -1; int j = 0; next[0] = -1; while(j &lt; pLen - 1)&#123; if(k == -1 || p[j] == p[k])&#123; k++; j++; if(p[j] != p[k])&#123; next[j] = k; &#125;else&#123; next[j] = next[k]; &#125; &#125;else&#123; k = next[k]; &#125; &#125; return next;&#125; 这样，求next数组的代码就已经实现了，下面给出KMP的算法： 123456789101112131415161718192021public static int KMPindexOf(String Source,String Pattern)&#123; int i = 0; int j = 0; char[] src = Source.toCharArray(); char[] ptn = Pattern.toCharArray(); int sLen = src.length; int pLen = ptn.length; int[] next = getNext(ptn); while(i &lt; sLen &amp;&amp; j &lt; pLen)&#123; if(j == -1 || src[i] == ptn[j])&#123; i++; j++; &#125;else&#123; j = next[j]; &#125; &#125; if(j == pLen)&#123; return i - j; &#125; return -1;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"关于 Web 开发的初级笔记","date":"2017-03-25T05:08:22.000Z","path":"2017/03/25/notes_02/","text":"不定期更新 转发和重定向的区别首先，转发是服务器行为，重定向是客户端行为。这可以从它们的运行过程进行分析。在转发的过程中，浏览器先给服务器发送 http 请求，服务器接收此请求后，调用容器内的方法完成处理和转发动作。注意，这里“转发”的路径必须是在同一个 web 容器下的 url，而不能转到其他的 web 路径上去。因此这里产生了一个判断方法：网址是任何一个web网址还是本站点下的网址。如果是任何一个其他 web 网址（且不为本站点的网址），那么所进行的动作就为重定向。接着分析，由于转发的行为是在同一个 web 容器下进行，且都在服务器端完成，因此 servlet 间共享的是一个 request，数据可以在不同的 servlet 和 jsp 之间传递。在重定向的过程中，在浏览器给服务器发送 http 请求，服务器接收此请求后，服务器给浏览器一个响应，告诉浏览器（客户端）“重新发送一个新的请求”给一个新的网址。而这个网址我们上文也提过了，可以是这个 web 容器内的网址，也可以是其他的网址。显然，这“重新发送的请求”和第一次发送的请求不是同一个请求，因此就形成了两个不同的 request，从而使得第二个 request 不能获得第一个 request 里的数据。 显式地观察，在转发行为中，浏览器的网址是不会发生改变的。因为最后转发到哪个网址，浏览器并不知道，它只完成了初次提交请求的动作，中间过程都由服务器负责。而在重定向行为里，网址会改变。因为它接收到了服务器的响应，并重新提交了新的 http 请求。 JSP include 指令 include 动作的区别1.include 指令 静态引入 web 资源，也就是说，被引入文件内容将作为使用 include 指令的 JSP 页面所生成的 Servlet 源码一部分而存在。若改变了被包含的文件，则主文件的代码就发生了变化，因此服务器会重新编译主文件。 可以改变 HTTP 响应头以及响应状态码 相对路径是相对于文件的 无论 JSP 文件的扩展名是不是.jsp，都会按照 JSP 页面处理 处理不存在的 web 资源时，会抛出异常 2.include 动作 动态引入 web 资源。被包含的文件改变不会影响到主文件，因此服务器不会对主文件重新编译，而只需要重新编译被包含的文件即可，而对被包含文件的编译是在执行时才进行的，也就是说，只有当 include 动作被执行时，使用该标识包含的目标文件才会被编译，否则被包含的文件不会被编译 不可以改变 HTTP 响应头以及响应状态码 相对路径是相对于页面的 包含的文件如果是其他扩展名，会将内容当做静态文件处理 处理不存在的 web 资源时，会继续执行","tags":[{"name":"JSP","slug":"JSP","permalink":"http://yoursite.com/tags/JSP/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"}]},{"title":"关于 javaIO 的一些笔记","date":"2017-03-15T13:26:12.000Z","path":"2017/03/15/notes_01/","text":"不定期更新 字节流 InputStream / OutputStreamInputStream:抽象了应用程序读取数据的能力OutputSream:抽象了应用程序写数据的能力 输入流基本方法in.read()读取一个字节无符号填充到int的低八位，-1 是EOFin.read(byte[] buf)读取数据填充到字节数组 bufin.read(byte[] buf,int start,int size) 输出流基本方法out.write(int b)写出一个 byte 到流，b的低八位out.write(byte[] buf)将 buf 字节数组都写入到流out.write(byte[] buf,int start,int size) FileInputStream在文件上读取数据FileInputStream in = new FileInputStream(fileName); FileOutputStream向文件中写出byte数据FileOutputStream out = new FileOutputStream(fileName); DataOutputStream/DataInputStream对流功能的扩展，可以更加方便地读取 int,long 字符等数据类型DataOutputStream dos = new DataOutputStream(new FileOutputSteam(Filename)); BufferedInputStream BufferedPOutputStream提供了带缓冲区的操作 一般文件打开或者读取时，都会加上缓冲，提高 IO的性能BufferedInputStream bis = new BufferedInputStream(new FileInoutStream(Filename)); 字符流 字符流 —&gt;文本，文本文件java的文本(char)是 16 位无符号整数，是 unicode 编码（双字节）文件是一个字节一个字节的数据序列文本文件是文本 char 序列按照某种编码方案序列化为 byte 的存储结果 字符流 Reader / WriterInputStreamReader 将 byte 流解析为 char 流，按照编码处理OutputStreamWriter 提供 char 流到 byte 流，按照编码处理InputStreamReader isr = new InputStream(new FileInputStream(Filename)); FileReader / FileWriterFileReader fr = new FileReader(Filename); BufferedReader / BufferedWriterBufferedReader—&gt;readLine 一次读一行 不识别换行BufferedWriter—&gt;write 写一行 不能换行PrinterWriter-&gt;println 可换行BufferedReader br = new BufferedReader(new FileInputStream(Filename))PrinterWriter pw = new PrinterWriter(Filename);","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"字节字符流","slug":"字节字符流","permalink":"http://yoursite.com/tags/字节字符流/"}]}]